{%- import 'go.macros' as go_macros -%}
// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.

#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

#define STR(x) #x
#define RSTR(x) STR(x)

// Simple typedef for a void* which we know is a c-api object.
{% for class in classes %}
typedef const void* {{module.name}}_{{class.name}};
{%- endfor %}


// Function pointers for each of the exposed functions.
// These will be set to the dlsym() results on initialisation.
{% for class in classes %}
{% for impl in class.impls -%}
{%- for method in impl.constructors -%}
typedef int (*{{module.name}}_{{impl.name}}_create_Ptr)(
    {{go_macros.c_method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* object);
static {{module.name}}_{{impl.name}}_create_Ptr {{module.name}}_{{impl.name}}_create_ptr = NULL;
{% endfor %}
{%- endfor -%}
{%- endfor %}

{% for class in classes %}
{% for method in class.methods %}
{% if method.is_noexcept %}
    {% if method.returns_void %}
    typedef void (*{{module.name}}_{{class.name}}_{{method.name}}_Ptr)(
            const void*
            {{go_macros.c_method_parameters(module, method, leading_comma=True)}});
    {% else %}
    typedef {{method.return_type|to_c(module.name)}} (*{{module.name}}_{{class.name}}_{{method.name}}_Ptr)(
            const void*
            {{go_macros.c_method_parameters(module, method, leading_comma=True)}});
    {% endif %}
{% else %}
typedef int (*{{module.name}}_{{class.name}}_{{method.name}}_Ptr)(
    const void*
    {{go_macros.c_method_parameters(module, method, leading_comma=True)}}
    {%- if not method.returns_void -%}
        , {{method.return_type|to_c(module.name)}}* rv
    {%- endif -%}
    );
{% endif %}
static {{module.name}}_{{class.name}}_{{method.name}}_Ptr {{module.name}}_{{class.name}}_{{method.name}}_ptr = NULL;
{% endfor %} 
{%- endfor %} 


int init() {
    // The progress code is incremented prior to each step below.  If a step
    // fails, this code is returned and used as the exit code from the Go
    // layer. This allows us to inspect the generated C source and determine at
    // which point the process of loading the library and resolving the symbols
    // failed. If everything succeeds, this function explicitly returns 0.
    int progress_code = 0;

    // Assume the DSO is two levels up from the Go module:
    {% if dso_extension is equalto 'dll' -%}
    const char* library_file = RSTR(SOURCE_PATH) "\\..\\..\\lib{{module.name}}_c.{{dso_extension}}";
    {%- else -%}
    const char* library_file = RSTR(SOURCE_PATH) "/../../lib{{module.name}}_c.{{dso_extension}}";
    {%- endif %}

    // Form the canonical path to the DSO and check that it points to a valid file.
    // This should permit early termination in the event that the DSO file is missing.
    ++progress_code;
    char* path = realpath(library_file, NULL);
    struct stat st;
    if (stat(path, &st) != 0) {
        // The file doesn't exist, or cannot be accessed.
        return progress_code;
    }

    // Load the module's dynamic library
    ++progress_code;
    void* dynamic_library = dlopen(path, RTLD_LOCAL | RTLD_LAZY);
    if (!dynamic_library) {
        return progress_code;
    }

    // Resolve the function pointers
    void* symbol = NULL;

    {% for class in classes %}
    {% for impl in class.impls -%}
    {% for method in impl.constructors %}
    ++progress_code;
    symbol = dlsym(dynamic_library, "{{module.name}}_{{impl.name}}_create");
    if (!symbol) {
        return progress_code;
    }
    {{module.name}}_{{impl.name}}_create_ptr = ({{module.name}}_{{impl.name}}_create_Ptr)symbol;
    {% endfor -%}
    {% endfor -%}
    {% endfor %}

    {%- for class in classes %}
    {%- for method in class.methods %}
    ++progress_code;
    {% if method.is_noexcept %}
    symbol = dlsym(dynamic_library, "{{module.name}}_{{class.name}}_{{method.name}}_noexcept");
    {% else %}
    symbol = dlsym(dynamic_library, "{{module.name}}_{{class.name}}_{{method.name}}");
    {% endif %}
    if (!symbol) {
        return progress_code;
    }
    {{module.name}}_{{class.name}}_{{method.name}}_ptr = ({{module.name}}_{{class.name}}_{{method.name}}_Ptr)symbol;
    {% endfor %}  
    {%- endfor %}  

    free(path);

    return 0;
}

{% for class in classes -%}
{% for impl in class.impls -%}
{%- for method in impl.constructors %}
typedef struct {{module.name}}_{{impl.name}}_create_return_type {
    {{module.name}}_{{class.name}} ptr;
    int status;
} RT_{{module.name}}_{{impl.name}}_create;

RT_{{module.name}}_{{impl.name}}_create CGo_{{module.name}}_{{impl.name}}_create({{go_macros.c_method_parameters(module, method)}}) {
    RT_{{module.name}}_{{impl.name}}_create rv;
    rv.status = {{module.name}}_{{impl.name}}_create_ptr(
        {{go_macros.c_method_arguments(method, trailing_comma=True)}}
        &rv.ptr);
    return rv;
}
{% endfor -%}
{%- endfor %}
{%- endfor %}

{% for class in classes -%}
{% for method in class.methods %}
typedef struct {{module.name}}_{{class.name}}_{{method.name}}_return_type {
    {% if not method.returns_void %}
    {{method.return_type|to_c(module.name)}} value;
    {% endif %}
    int status;
} RT_{{module.name}}_{{class.name}}_{{method.name}};

RT_{{module.name}}_{{class.name}}_{{method.name}} CGo_{{module.name}}_{{class.name}}_{{method.name}}(
    {{module.name}}_{{class.name}} my{{class.name}} {{go_macros.c_method_parameters(module, method, leading_comma=True)}}) {
    RT_{{module.name}}_{{class.name}}_{{method.name}} rv;
    {% if method.is_noexcept %}
    rv.status = 0;
        {% if method.returns_void %}
        {{module.name}}_{{class.name}}_{{method.name}}_ptr(
            my{{class.name}}
            {{go_macros.c_method_arguments(method, leading_comma=True)}});
        {% else %}
        rv.value = {{module.name}}_{{class.name}}_{{method.name}}_ptr(
                my{{class.name}}
                {{go_macros.c_method_arguments(method, leading_comma=True)}});
        {% endif %}
    {% else %}
    rv.status = {{module.name}}_{{class.name}}_{{method.name}}_ptr(
        my{{class.name}}
        {{go_macros.c_method_arguments(method, leading_comma=True)}}
        {%- if not method.returns_void -%},
        &rv.value
        {%- endif -%});
    {% endif %}
    return rv;
}
{% endfor %}  
{%- endfor %}  
