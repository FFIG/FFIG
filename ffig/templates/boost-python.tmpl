{% import 'ffig.macros' as ffig_macros -%}

{#
 # method_parameters:
 #   Generates a list of parameter types and names suitable for use in a
 #   function declaration or definition. Commas are inserted between each
 #   element of the list. Leading and trailing commas can be added by setting
 #   leading_comma or trailing_comma to True as appropriate. This is useful
 #   if there are other parameters that must be declared.
 #}
{% macro method_parameters(method, leading_comma=False, trailing_comma=False) %}
    {% call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.type}} {{arg.name}}
    {%- endcall %}
{% endmacro -%}

{#
 # method_arguments:
 #   Generates a list of argument names suitable for use in a
 #   function call.  Commas are inserted between each element of the list.
 #   Leading and trailing commas can be added by setting leading_comma or
 #   trailing_comma to True as appropriate. This is useful if there are other
 #   parameters that must be declared.
 #}
{% macro method_arguments(method, leading_comma=False, trailing_comma=False) %}
    {% call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.type}}
    {%- endcall %}
{% endmacro -%}

{% macro method_values(method, leading_comma=False, trailing_comma=False) %}
    {% call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.name}}
    {%- endcall %}
{% endmacro -%}

// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.
#include <boost/python.hpp>
#include "{{module.name}}.h"

BOOST_PYTHON_MODULE({{module.name}}_py3)
{
  using namespace boost::python;

{% for class in classes %}
{% if class.is_abstract %}
  struct {{class.name}}Wrap : {{class.name}}, wrapper<{{class.name}}>
  {
    {% for method in class.methods %}
    {% if method.is_property %}
    {{method.return_type}} {{method.name}}({{method_parameters(method)}}) {
      return this->get_override("{{method.name}}")({{method_values(method)}});
    }

    {{method.return_type}} default_{{method.name}}({{method_parameters(method)}}) {
      return this->get_override("{{method.name}}")({{method_values(method)}});
    }

    {% endif %}
    {% endfor %}
  };
  
  class_<{{class.name}}, boost::noncopyable>("{{class.name}}", no_init)
    {% for method in class.methods %}
    {% if method.is_property %}
    .add_property("{{method.name}}", &{{class.name}}::{{method.name}}, &{{class.name}}Wrap::default_{{method.name}})
    {% endif %}
    {% endfor %}
  ;
  
{% endif %}

{% for impl in class.impls %}
  class_<{{impl.name}}, bases<{{class.name}}> >("{{impl.name}}"{% for constructor in impl.constructors %}, init<{{method_arguments(constructor)}}>(){% endfor %})
  ;

{% endfor %}
{% endfor %}
}
