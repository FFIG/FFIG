{%- macro method_parameter_list(method, final_comma=False) -%}
{%- for arg in method.arguments -%}
{{arg.type | to_c(module.name)}} {{arg.name}}
{%- if final_comma -%}
,
{%- elif not loop.last -%}
,
{%- endif -%}
{%- endfor -%}
{%- endmacro -%}

{%- macro method_arguments(method, final_comma=False) -%}
{%- for arg in method.arguments -%}
{{arg | restore_cpp_type}}
{%- if final_comma -%}
,
{%- elif not loop.last -%}
,
{%- endif -%}
{%- endfor -%}
{%- endmacro -%}

// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.

#include <memory>
#include <string>
#include "{{module.name}}_c.h"
#include "{{module.name}}.h"

static thread_local std::string {{module.name}}_error_;

void {{module.name}}_clear_error()
{
  {{module.name}}_error_.clear();
}

const char* {{module.name}}_error()
{
  return {{module.name}}_error_.c_str();
}

namespace {
    using {{class.name}}_ptr = const std::shared_ptr<{{class.name}}>*;
} // end anonymous namespace

void {{module.name}}_{{ class.name }}_dispose({{module.name}}_{{class.name}} my{{class.name}})
{
  delete static_cast<{{class.name}}_ptr>(my{{class.name}});
}

{% if not class.is_abstract -%}
{% for method in class.constructors %}
int {{module.name}}_{{class.name}}_create(
    {{method_parameter_list(method, final_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<const {{class.name}}>({{method_arguments(method)}});
        *rv = new std::shared_ptr<const {{class.name}}>(p.release());
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% endfor %}
{%- endif -%}

{% for method in class.methods %}
int {{module.name}}_{{class.name}}_{{method.name}}(
    {{module.name}}_{{class.name}} my{{class.name}},
    {%- if method.returns_void -%}
    {{method_parameter_list(method)}}
    {%- else -%}
    {{method_parameter_list(method, final_comma=True)}}
    {{method.return_type | to_c(module.name)}}* rv
    {%- endif -%}
    )
{
    try
    {
        {% if method.returns_void -%}
        (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.name}}(
            {{method_arguments(method)}});
        {%- elif not method.returns_sub_object -%}
        *rv = (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.name}}(
            {{method_arguments(method)}});
        {%- else -%}
        auto p = static_cast<const {{class.name}}_ptr>(my{{class.name}});
        auto subobj = (*p)->{{method.name}}(
            {{method_arguments(method)}});
        {% if method.returns_nullable -%}
        if (!subobj)
        {
            *rv = nullptr;
            return {{module.name}}_RC_SUCCESS;
        }
        {%- endif -%}
        *rv = new std::shared_ptr<{{method.return_type.pointee}}>(*p, subobj);
        {%- endif %}
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% endfor %}

{%- for impl in impl_classes %}
{% for method in impl.constructors %}
int {{module.name}}_{{impl.name}}_create(
    {{method_parameter_list(method, final_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<const {{impl.name}}>({{method_arguments(method)}});
        *rv = new std::shared_ptr<const {{class.name}}>(p.release());
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{%- endfor %}
{%- endfor %}
