#include <memory>
#include <string>
#include "{{module.name}}_c.h"
#include "{{module.name}}.h"

static thread_local std::string {{module.name}}_error_;

void {{module.name}}_clear_error()
{
  {{module.name}}_error_.clear();
}

const char* {{module.name}}_error()
{
  return {{module.name}}_error_.c_str();
}

namespace {
using {{class.name}}_ptr = const std::shared_ptr<{{class.name}}>*;
} // end anonymous namespace

void {{ class.name }}_dispose(const void* my{{class.name}})
{
  delete static_cast<{{class.name}}_ptr>(my{{class.name}});
}
{% if not class.is_abstract %}{% for method in class.constructors %}
int {{class.name}}_{{ class.name }}_create({% for arg in method.arguments %}{{arg.type|to_c}} {{arg.name}},{% endfor %} const void** rv)
{
  try
  {
    auto p = std::make_unique<const {{class.name}}>({% for arg in method.arguments %}{% if not loop.first %}, {% endif %}{{arg.type|restore_cpp_type(arg.name)}}{% endfor %});
    *rv = new std::shared_ptr<const {{class.name}}>(p.release());
  }
  catch(const std::exception& e)
  {
    {{module.name}}_error_ = e.what();
    return {{module.name}}_RC_FAIL;
  }
  return {{module.name}}_RC_SUCCESS;
}
{% endfor %} {% endif %} {% for method in class.methods %}
int {{ class.name }}_{{method.name}}(const void* my{{class.name}}{% for arg in method.arguments %}, {{arg.type|to_c}} {{arg.name}}{% endfor %}{% if not method.returns_void %}, {{method.return_type|to_c}}* rv{% endif %})
{
  try
  {
    {% if method.returns_void %} (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.name}}({% for arg in method.arguments %}{% if not loop.first %}, {% endif %}{{arg.type|restore_cpp_type(arg.name)}}{% endfor %});
    {% elif not method.returns_sub_object %}*rv = (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.name}}({% for arg in method.arguments %}{% if not loop.first %}, {% endif %}{{arg.type|restore_cpp_type(arg.name)}}{% endfor %});
    {% else %}auto p = static_cast<const {{class.name}}_ptr>(my{{class.name}});
    auto subobj = (*p)->{{method.name}}({% for arg in method.arguments %}{% if not loop.first %}, {% endif %}{{arg.type|restore_cpp_type(arg.name)}}{% endfor %});
    {% if method.returns_nullable %}if (!subobj)
    {
      *rv = nullptr;
      return {{module.name}}_RC_SUCCESS;
    }{% endif %}
    *rv = new std::shared_ptr<{{method.return_type.pointee}}>(*p, subobj);{% endif %}
  }
  catch(const std::exception& e)
  {
    {{module.name}}_error_ = e.what();
    return {{module.name}}_RC_FAIL;
  }
  return {{module.name}}_RC_SUCCESS;
}
{% endfor %} {% for impl in impl_classes %} {% for method in impl.constructors %}
int {{class.name}}_{{ impl.name }}_create({% for arg in method.arguments %}{{arg.type|to_c}} {{arg.name}},{% endfor %} const void** rv)
{
  try
  {
    auto p = std::make_unique<const {{impl.name}}>({% for arg in method.arguments %}{% if not loop.first %}, {% endif %}{{arg.type|restore_cpp_type(arg.name)}}{% endfor %});
    *rv = new std::shared_ptr<const {{class.name}}>(p.release());
  }
  catch(const std::exception& e)
  {
    {{module.name}}_error_ = e.what();
    return {{module.name}}_RC_FAIL;
  }
  return {{module.name}}_RC_SUCCESS;
}
{% endfor %} {% endfor %}
