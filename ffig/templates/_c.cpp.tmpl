{% import '_c.macros' as c_macros %}
// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.

#include <memory>
#include <string>
#include "{{module.name}}_c.h"
#include "{{module.name}}.h"

static thread_local std::string {{module.name}}_error_;

void {{module.name}}_clear_error()
{
  {{module.name}}_error_.clear();
}

const char* {{module.name}}_error()
{
  return {{module.name}}_error_.c_str();
}

namespace {
{% for class in classes %}
  using {{class.name}}_ptr = std::shared_ptr<{{class.impl_name}}>*;
{% endfor %}

// C-API types are pointers to undefined structs so that a C compiler can warn 
// if they are used in the wrong places 
// (CAPIShape_t* and CAPITree_t* are not the same type).
// Wrappers around reinterpret_cast allow casts to and from C-API types to be checked.

template <class CppType> struct capi_type_t;
{% for class in classes %}
template<> struct capi_type_t<{{class.impl_name}}> { using type = {{module.name}}_{{class.name}}; };
{% endfor %}
template <class T>
using capi_type = typename capi_type_t<T>::type;

template<class CppType>
auto capi_to_cpp_cast(capi_type<CppType> o) { 
  return reinterpret_cast<std::shared_ptr<CppType>*>(o);
}

template<class CppType>
void* capi_to_cpp_cast(...) = delete;

template<class CppType>
auto cpp_to_capi_cast(std::shared_ptr<CppType>* p) { 
  return reinterpret_cast<capi_type<CppType>>(p);
}
void* cpp_to_capi_cast(...) = delete;

} // end anonymous namespace

{% for class in classes %}
void {{module.name}}_{{ class.name }}_dispose({{module.name}}_{{class.name}} my{{class.name}})
{
  delete capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}});
}
{% if not class.is_abstract %}
{% for method in class.constructors %}

int {{module.name}}_{{class.name}}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<{{class.impl_name}}>({{c_macros.method_arguments(method)}});
        auto new_obj = new std::shared_ptr<{{class.impl_name}}>(p.release());
        *rv = cpp_to_capi_cast(new_obj);
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

{{module.name}}_{{class.name}} {{module.name}}_{{ class.name }}_create_noexcept(
    {{c_macros.method_parameters(module, method)}}) 
{
    auto p = std::make_unique<{{class.impl_name}}>({{c_macros.method_arguments(method)}});
    auto new_obj = new std::shared_ptr<{{class.impl_name}}>(p.release());
    return cpp_to_capi_cast(new_obj);
}
{% endif %}
{% endfor %}
{% endif %}
{% for method in class.methods %}

int {{module.name}}_{{class.name}}_{{method.name}}(
    {{module.name}}_{{class.name}} my{{class.name}}
    {% if method.returns_void %}
    {{c_macros.method_parameters(module, method, leading_comma=True)}}
    {% else %}
    {{c_macros.method_parameters(module, method, leading_comma=True, trailing_comma=False)}},
    {{method.return_type | to_c(module.name)}}* rv
    {% endif %}
    )
{
    try
    {
        {% if method.returns_void %}
        (*capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}}))->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% elif not method.returns_sub_object %}
        *rv = (*capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}}))->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% else %}
        auto p = capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}});
        auto subobj = (*p)->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% if method.returns_nullable %}
        if (!subobj)
        {
            *rv = nullptr;
            return {{module.name}}_RC_SUCCESS;
        }
        {% endif %}
        auto new_obj = new std::shared_ptr<std::remove_reference_t<decltype(*subobj)>>(*p, subobj);
        *rv = cpp_to_capi_cast(new_obj);
        {% endif %}
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

EXPORT {{method.return_type | to_c(module.name)}} {{module.name}}_{{ class.name }}_{{method.name}}_noexcept(
    {{module.name}}_{{class.name}} my{{class.name}} {{c_macros.method_parameters(module, method, leading_comma=True)}})
{
    {% if method.returns_void %}
    (*capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}}))->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% elif not method.returns_sub_object %}
    return (*capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}}))->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% else %}
    auto p = capi_to_cpp_cast<{{class.impl_name}}>(my{{class.name}});
    auto subobj = (*p)->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% if method.returns_nullable %}
    if (!subobj)
    {
        return nullptr;
    }
    {% endif %}
    auto new_obj = new std::shared_ptr<std::remove_reference_t<decltype(*subobj)>>(*p, subobj);
    return cpp_to_capi_cast(new_obj);
    {% endif %}
}
{% endif %}
{% endfor %}
{% for impl in class.impls %}
{% for method in impl.constructors %}

int {{module.name}}_{{impl.name}}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<{{impl.impl_name}}>({{c_macros.method_arguments(method)}});
        auto new_obj = new std::shared_ptr<{{class.impl_name}}>(p.release());
        *rv = cpp_to_capi_cast(new_obj);
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

{{module.name}}_{{class.name}} {{module.name}}_{{impl.name}}_create_noexcept(
    {{c_macros.method_parameters(module, method)}}) 
{
    auto p = std::make_unique<{{impl.impl_name}}>({{c_macros.method_arguments(method)}});
    auto new_obj = (new std::shared_ptr<{{class.impl_name}}>(p.release()));
    return cpp_to_capi_cast(new_obj);
}
{% endif %}
{% endfor %}
{% endfor %}
{% endfor %}
