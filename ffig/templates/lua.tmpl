{%- import 'ffig.macros' as ffig_macros -%}
{%- import '_c.macros' as c_macros -%}
{#
 # method_arguments:
 #   Generates a list of argument names suitable for use in a
 #   function call.  Commas are inserted between each element of the list.
 #   Leading and trailing commas can be added by setting leading_comma or
 #   trailing_comma to True as appropriate. This is useful if there are other
 #   parameters that must be declared.
 #}
{%- macro method_arguments(method, leading_comma=False, trailing_comma=False) -%}
    {%- call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.name}}
    {%- endcall -%}
{%- endmacro -%}

-- This code was generated by FFIG <http://ffig.org>.
-- Manual edits will be lost.
local ffi = require("ffi")
ffi.cdef[[
{% for class in classes %}
typedef const void* {{module.name}}_{{class.name}};
{%- endfor %}

void {{module.name}}_clear_error();

const char* {{module.name}}_error();

{% for class in classes %}
void {{module.name}}_{{class.name}}_dispose({{module.name}}_{{class.name}} my{{class.name}});

{% if not class.is_abstract -%}
{% for method in class.constructors %}
int {{module.name}}_{{ class.name }}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv);
{% endfor %}
{%- endif -%}

{% for method in class.methods %}
int {{module.name}}_{{ class.name }}_{{method.name}}(
    {{module.name}}_{{class.name}} my{{class.name}}
    {%- if method.returns_void -%}
        {{c_macros.method_parameters(module, method, leading_comma=True)}}
    {%- else -%}
        {{c_macros.method_parameters(module, method, leading_comma=True, trailing_comma=False)}},
        {{method.return_type | to_c(module.name)}}* rv
    {%- endif -%}
    );
{% endfor %}

{%- for impl in class.impls %}
{% for method in impl.constructors %}
int {{module.name}}_{{ impl.name }}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv);
{%- endfor %}
{%- endfor %}
]]

local lib{{module.name}} = ffi.load("{{module.name}}_c")

{{class.name}} = {}
{{class.name}}.__index = {{class.name}}

function {{module.name}}_clear_error()
  lib{{module.name}}.{{module.name}}_clear_error()
end

function {{module.name}}_error()
  return ffi.string(lib{{module.name}}.{{module.name}}_error())
end

{% if not class.is_abstract -%}
{% for method in class.constructors %}
function {{class.name}}:new(o)
  local o = o or {}
  setmetatable(o, self)
  self.__index = self
  v = ffi.new("const void*[1]")
  rc = lib{{module.name}}.{{module.name}}_{{class.name}}_{{method.name}}({{method_arguments(method, trailing_comma=True)}}v)
  o.ptr = v[0]
return o
end
{%- endfor -%}
{%- endif %}

{% for impl in class.impls %}
{{impl.name}} = {}
{% for method in impl.constructors %}
function {{impl.name}}:new(o)
  local o = o or {}
  setmetatable(o, self)
  self.__index = {{class.name}}
  v = ffi.new("const void*[1]")
  rc = lib{{module.name}}.{{module.name}}_{{impl.name}}_create({{method_arguments(method, trailing_comma=True)}}v)
  o.ptr = v[0]
return o
end
{%- endfor -%}
{% endfor %}

{% for method in class.methods %}
function {{class.name}}:{{method.name}}()
  v = ffi.new("{{method.return_type.name}}[1]")
  rc = lib{{module.name}}.{{module.name}}_{{class.name}}_{{method.name}}(self.ptr, {{method_arguments(method, trailing_comma=True)}}v)
  return {{method.return_type|to_lua("v[0]")}}
end
{% endfor %}
{%- endfor %}

