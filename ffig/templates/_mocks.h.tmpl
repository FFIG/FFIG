{%- import 'ffig.macros' as ffig_macros -%}

{#
 # method_type_list:
 #   List of types of method parameters, without parameter names.
 #}
{%- macro method_type_list(method, leading_comma=False, trailing_comma=False) -%}
    {%- call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.type}}
    {%- endcall -%}
{%- endmacro -%}

{#
 # method_parameters:
 #   Method parameters (type and name) separated by commas.
 #}
{%- macro method_parameters(method, leading_comma=False, trailing_comma=False) -%}
    {%- call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.type}} {{arg.name}}
    {%- endcall -%}
{%- endmacro -%}

{#
 # method_arguments:
 #   Method arguments (name only) separated by commas.
 #}
{%- macro method_arguments(method, leading_comma=False, trailing_comma=False) -%}
    {%- call(arg) ffig_macros.comma_separated_list(method.arguments, leading_comma, trailing_comma) -%}
        {{arg.name}}
    {%- endcall -%}
{%- endmacro -%}
// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.

#include "{{module.name}}.h"
#include <exception>
#include <eggs/variant.hpp>
#include <functional>
namespace mocks {

{% for class in classes %}
struct Mock{{class.name}} : {{class.name}}
{
  enum state
  {
    value,
    function
  };

  struct MockMethodResultNotSpecified : std::logic_error
  {
    using std::logic_error::logic_error ;
  };

  struct MockMethodResult
  {
    template <typename Value, typename ...Args>
    auto operator()(const char* method_name, const Value& v, Args&& ...args) const
    {
      switch(v.which())
      {
        case(value):
          return eggs::variants::get<value>(v);
        case(function):
          return eggs::variants::get<function>(v)(std::forward<Args>(args)...);
        default:
          throw MockMethodResultNotSpecified(method_name);
      }
    }
  };

{% for method in class.methods %}
  eggs::variant<{{method.return_type}}, std::function<{{method.return_type}}({{method_type_list(method)}})>> {{method.name}}_;
{%endfor%}

{% for method in class.methods %}
  {% if method.is_noexcept %}
  {{method.return_type}} {{method.name}}({{method_parameters(method)}}) const noexcept override
  {% else %}
  {{method.return_type}} {{method.name}}({{method_parameters(method)}}) const override
  {% endif %}
  {
    return MockMethodResult()("{{method.name}}", {{method.name}}_
            {{method_arguments(method, leading_comma=True)}});
  }
{% endfor %}
};
{% endfor %}
} // end namespace mocks
