FFIG – Bindings – Go
====================
This document describes how FFIG generates bindings for the Go language. The CGo interface is used to connect Go to the C library that is the entry point for the other language bindings.

The template `go.c.tmpl` is used to generate a `.h` file. There's nothing special that makes this a "header" file, except that it gets `#include`d into the CGo section of the Go module (see below).

The template produces a pure C file which uses the `dlopen` and `dlsym` functions to load and resolve symbols from the C library produced by FFIG. This is done because CGo itself does not support dynamic linking, so we link statically to `libdl`, then use `libdl` to dynamically resolve the symbols we need.

The CGo Part – Preamble
-----------------------
Given the class definition,

```c++
class Shape {
  public:
    virtual double area() const;
    // ...
};
```

the C bindings produce a function,

```c
int Shape_area(const void* object, double* return_value);
```
where the first argument is a pointer to (a shared pointer to) the `Shape` object on which the `area()` function should be invoked, the second argument is used to hold the return value of the call to `area()`, and the returned integer is an error code / status indicator.

The C file used in the Go bindings will begin with a typedef for a pointer to this function, followed by a static variable of this type:

```c
typedef int (*Shape_area_Ptr)(const void*, double*);
static Shape_area_Ptr Shape_area_ptr;
```

These function pointers form the basis of the mechanism by which the Go bindings work. They are populated by the `init()` function which is described below.

The CGo Part – The `init()` function
------------------------------------
The `init()` function uses the `SOURCE_PATH` string defined in the CGo section of the generated Go file. This contains the path to the Go module. This string is used to build the path to the C library DSO generated by the C bindings. It is assumed that this library resides two directories higher up the tree than the Go module does, i.e. at
`SOURCE_PATH/../../libShape_c.so` for the example above.

After forming the expected path to the DSO, we `stat` the file to check that it exists. This allows us to terminate early in the event that file file is missing, or incorrectly named. The next step is to `dlopen` the DSO using the filename we constructed.

Once the library has been opened, the template produces a section of code for each exposed function. This code section uses `dlsym` to look up the symbol in the C library, then assigns the returned pointer to the appropriate static function pointer (described above).

At the end of the `init()` function, the memory that was allocated to hold the path to the DSO is freed, and a zero status is returned to indicate success.

The CGo Part – Error reporting in the `init()` function
-------------------------------------------------------
The `init()` function returns `0` on success, and a non-zero value on failure. The non-zero failure status is an indicator of how far through the initialisation we got before an error was detected.

This is achieved by setting an integer variable called `progress_code` to `0` at the top of the function, and incrementing it before each step of the initialisation. Non-zero return values from `init()` become non-zero exit status from the resulting Go program, and can be used to refer to the generated C file to determine which initialisation step failed. The most common are `1`, indicating that the call to `stat` failed (i.e. the DSO does not exist at the expected path), or `2`, indicating that the `dlopen` call failed. Values of `3` or higher refer to a failure to resolve a particular symbol. Determining which symbol is achieved by counting through the steps in the generated code.

This error reporting mechanism is far from perfect, but due to the lack of exceptions in Go, and the rudimentary nature of the interface between C and Go, it's better to have some information rather than none at all. In particular, we do not want the general purpose bindings to assume that it is safe to write an error string to `stdout` or `stderr`. A future enhancement may be to provide something akin to `errno`, which could be used to query the CGo layer for an error string that the Go code could decide what to do with.

The CGo Part – The interface functions
--------------------------------------
Each interface function is preceded by the definition of a struct to hold the returned value and the status code. In the example for `Shape::area()`, this would look like

```c
typedef struct Shape_area_return_type {
  double value;
  int status;
} RT_Shape_area;
```

where `value` is the space into which the result of calling `Shape::area()` will be written, and `status` is the return status indicator from the C bindings. This struct is used to hold these values to pass back to the pure Go layer.

For each exposed function, the interface function is named with a `CGo_` prefix, and simply calls the appropriate function from the C bindings DSO, via the static pointers that were set up in the `init()` function. For example,

```c
RT_Shape_area CGo_Shape_area(const void* object) {
  RT_Shape_area rv;
  rv.status = Shape_area_ptr(object, &rv.value);
  return rv;
}
```

The Go Part – CGo initialisation
--------------------------------
The Go layer is more straightforward. It begins with the package definition, followed by a CGo section that looks something like

```Go
// #cgo CFLAGS: -std=c11 -I${SRCDIR} -DSOURCE_PATH=${SRCDIR}
// #cgo LDFLAGS: -ldl
#include "Shape.go.h"
```

This sets the `CFLAGS` and `LDFLAGS` to use C11 and to link against `libdl`. In addition, it uses the special CGo variable `${SRCDIR}` to define the include directory for finding `Shape.go.h`, and to provide the `SOURCE_PATH` definition that the CGo layer uses to locate the C bindings DSO relative to this module.

Then, there is a Go `init()` function, which is called automatically when the Go module is imported. This function just calls the `C.init()` function from the CGo layer (which, as described above, causes the C bindings DSO to be loaded and the exposed functions to be resolved and bound to function pointers). Any error from the CGo `init()` function is translated into an exit status here.

The Go Part – Go Bindings
-------------------------
The Go bindings themselves are relatively straightforward. A Go struct is defined for the type, which holds a pointer to an object of the appropriate C++ type. For example,

```Go
type Shape struct {
  ptr unsafe.Pointer
  }
```

Then, each exposed function is provided as a Go function. The order of proceedings is to first create an object of the appropriate return value type, as defined in the CGo layer, then to call the CGo function, check the return code and translate the return value and / or error code into appropriate Go types (or pointers to further C++ types):

```Go
func Shape_area(obj Shape) (float64, bool) {
  var rv C.RT_Shape_area
  rv = C.CGo_Shape_area(obj.ptr)
  
  if rv.status == 0 {
    value := float64(rv.value)
    return value, true
  } else {
    var value float64
    return value, false
  }
}
```

The type conversions are defined in `ffig/filters/capi_filter.py` within the `to_go` and `to_go_convert` functions. These are applied as appropriate by the `go.tmpl` template.

Further Work
------------
The Go bindings are a work in progress. At the time of writing, there are several open tickets to improve them. In particular, the exposed functions should be bound as member functions of the Go struct, and memory management should be taken care of to the extent that it is possible in Go.
