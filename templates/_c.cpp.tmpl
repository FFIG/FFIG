#include <new>
#include <string>
#include "{{class.name}}_c.h"
#include "{{class.name}}.h"

{% load capi_filter %}
// thread_local won't work on Apple clang:
// http://stackoverflow.com/questions/28094794/why-does-apple-clang-disallow-c11-thread-local-when-official-clang-supports/29929949#29929949
static thread_local std::string {{class.name}}_error_;

void {{class.name}}_clear_error()
{
  {{class.name}}_error_.clear();
}

const char* {{class.name}}_error()
{
  return {{class.name}}_error_.c_str();
}

void {{ class.name }}_dispose(const void* my{{class.name}})
{
  delete reinterpret_cast<const {{class.name}}*>(my{{class.name}});
}
{% for method in class.methods %}
int {{ class.name }}_{{method.name}}(const void* my{{class.name}}{% for arg in method.arguments %}, {{arg.type|to_c}} {{arg.name}}{% endfor %}, {{method.return_type|to_c}}* rv)
{
  try 
  {
    *rv = reinterpret_cast<const {{class.name}}*>(my{{class.name}})->{{method.name}}({% for arg in method.arguments %}{% if not forloop.first %}, {% endif %}{{arg.type|cast_c_type}}{{arg.name}}{% endfor %});
  }
  catch(const std::exception& e)
  {
    return {{class.name}}_RC_FAIL;
  }
  return {{class.name}}_RC_SUCCESS;
}
{% endfor %} {% for impl in impl_classes %} {% for method in impl.constructors %}
int {{class.name}}_{{ impl.name }}_create({% for arg in method.arguments %}{{arg.type|to_c}} {{arg.name}},{% endfor %} const void** rv)
{
  try
  {
    *rv = new (std::nothrow) {{ impl.name }}({% for arg in method.arguments %}{% if not forloop.first %}, {% endif %}{{arg.type|cast_c_type}}{{arg.name}}{% endfor %});
  }
  catch(const std::exception& e)
  {
    return {{class.name}}_RC_FAIL;
  }
  return {{class.name}}_RC_SUCCESS;
}
{% endfor %} {% endfor %}
